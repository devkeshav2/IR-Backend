Hereâ€™s a curated list of **100 Linked List questions** for DSA preparation, categorized by difficulty and concept type â€” covering singly, doubly, circular linked lists, and advanced techniques (recursion, two-pointer, hash, stack, merge-sort, etc.).

---

## ğŸ”° **Basic Level (Singly Linked List)**

1. Create a linked list

2. Traverse a linked list

3. Insert at beginning

4. Insert at end

5. Insert at a given position

6. Delete from beginning

7. Delete from end

8. Delete from a given position

9. Search an element

10. Find length of linked list

11. Find middle element (Tortoise & Hare)

12. Reverse a linked list (iterative)

13. Reverse a linked list (recursive)

14. Find Nth node from end

15. Delete Nth node from end

16. Remove duplicates from sorted list

17. Remove duplicates from unsorted list

18. Detect loop (Floydâ€™s cycle detection)

19. Find starting point of loop

20. Remove loop

---

## ğŸ” **Intermediate Level**

21. Check if linked list is palindrome

22. Merge two sorted linked lists

23. Add two numbers represented by linked list

24. Sort a linked list using merge sort

25. Clone a linked list with random pointers

26. Intersection point of two linked lists

27. Check if two linked lists intersect

28. Find first common node

29. Check if linked list is circular

30. Convert binary number in linked list to integer

31. Rotate linked list by k nodes

32. Segregate even and odd nodes

33. Pairwise swap elements

34. Rearrange nodes in zigzag fashion

35. Flatten a multilevel linked list

36. Delete node without head pointer

37. Swap kth node from start and end

38. Alternate K nodes reversal

39. Split circular linked list in two halves

40. Move last element to front

---

## ğŸ“¦ **Doubly Linked List**

41. Create a doubly linked list
42. Insert at beginning in DLL
43. Insert at end in DLL
44. Insert at given position in DLL
45. Delete a node from DLL
46. Reverse a doubly linked list
47. Check if DLL is palindrome
48. Convert DLL to binary tree
49. Convert binary tree to DLL
50. Merge two sorted doubly linked lists

---

## ğŸ”„ **Circular Linked List**

51. Create a circular linked list
52. Insert in circular linked list
53. Delete in circular linked list
54. Check if list is circular
55. Josephus problem
56. Split circular list into two
57. Convert circular linked list to singly
58. Count nodes in circular linked list
59. Sorted insert in circular linked list
60. Find length of circular list

---

## ğŸ§  **Advanced (Recursion / Pointers / Hashing)**

61. Reverse in groups of k nodes
62. Reverse alternate k nodes
63. Flatten a linked list (bottom pointers)
64. Add one to number represented by list
65. Multiply two linked lists
66. Convert linked list to balanced BST
67. Convert binary tree to DLL (in-order)
68. Copy linked list with random pointers
69. Merge K sorted linked lists
70. Reorder linked list (L0 â†’ Ln â†’ L1 â†’ Ln-1...)

---

## ğŸ” **Cycle Detection / Tortoise-Hare**

71. Find cycle length
72. Detect and remove loop
73. Starting point of loop
74. Reverse a looped part of linked list
75. Loop in DLL â€“ detect and remove

---

## ğŸ”¢ **Arithmetic with Linked List**

76. Add numbers in reverse order
77. Add numbers in forward order
78. Multiply two linked list numbers
79. Subtract two numbers
80. Compare two numbers represented as LL

---

## ğŸ§© **Rearrangements and Reordering**

81. Odd-Even positional rearrangement
82. Merge alternate nodes of two lists
83. Skip M delete N nodes
84. Delete alternate nodes
85. Alternate split of linked list
86. Fold linked list
87. Merge nodes between zeroes
88. Move all even-position nodes after odd ones
89. Convert LL to zigzag
90. Zip two linked lists

---

## ğŸ›  **Custom Data / Object-oriented**

91. Implement LRU Cache using DLL
92. Design a circular buffer
93. Implement deque using linked list
94. Design browser history with linked list
95. Implement a stack using linked list
96. Implement a queue using linked list
97. Multilevel linked list traversal
98. Convert string to linked list
99. Convert array to linked list
100. Serialize and deserialize a linked list

---

### ğŸ§­ Suggestions for Practice:

* Start with **singly linked list** (basic insert/delete/search/reverse)
* Move on to **pointer tricks and recursion**
* Then learn **doubly and circular lists**
* Finally tackle **application-based** problems like LRU, arithmetic, flattening, merge-k lists, etc.

---

Would you like:

* Java-based **solutions for each** (in batches of 10 or 20)?
* A **printable PDF/Excel sheet** version?
* Grouped **DSA patterns with solutions** (e.g., â€œCycle Detectionâ€, â€œTwo-pointerâ€, â€œStack-based LL problemsâ€)?

Let me know your preferred next step!
